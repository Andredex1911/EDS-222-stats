---
title: "Spatial interpolation and kriging"
subtitle: "EDS 222"
author: "Tamma Carleton"
#institute: ""
date: "Fall 2021"
output:
  xaringan::moon_reader:
    css: ['default', 'metropolis', 'metropolis-fonts', 'my-css.css']
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
---
```{r Setup, include = F}
options(htmltools.dir.version = FALSE)
library(pacman)
p_load(leaflet, ggplot2, ggthemes, viridis, dplyr, magrittr, knitr,pagedown,cowplot,latex2exp,gg3D)

rootdir <- ("~/Dropbox/Teaching/UCSB/EDS_222/EDS222_data")
source(file.path(rootdir,"labs","_common.R"))

# Define pink color
red_pink <- "#e64173"
# Notes directory
dir_slides <- "~/Dropbox/Teaching/UCSB/EDS_222/EDS222_code/EDS-222-stats/slides/08-kriging/"
# Knitr options
opts_chunk$set(
  comment = "#>",
  fig.align = "center",
  fig.height = 7,
  fig.width = 10.5,
  # dpi = 300,
  # cache = T,
  warning = F,
  message = F,
  dev = "svg"
)
# A blank theme for ggplot
theme_empty <- theme_bw() + theme(
  line = element_blank(),
  rect = element_blank(),
  strip.text = element_blank(),
  axis.text = element_blank(),
  plot.title = element_blank(),
  axis.title = element_blank(),
  plot.margin = structure(c(0, 0, -1, -1), unit = "lines", valid.unit = 3L, class = "unit"),
  legend.position = "none"
)
theme_simple <- theme_bw() + theme(
  line = element_blank(),
  panel.grid = element_blank(),
  rect = element_blank(),
  strip.text = element_blank(),
  axis.text.x = element_text(size = 14),
  axis.text.y = element_blank(),
  axis.ticks = element_blank(),
  plot.title = element_blank(),
  axis.title = element_blank(),
  # plot.margin = structure(c(0, 0, -1, -1), unit = "lines", valid.unit = 3L, class = "unit"),
  legend.position = "none"
)
```

```{css, echo = FALSE}
@media print {
  .has-continuation {
    display: block;
  }
}
```

# Announcements/check-in

- Final projects guidelines 

--

- **Change in office hours** for week of 11/15 to Thursday 11/18 1:30pm-2:30pm

--

- **No class** 11/11; **remote class** 11/23, **no class** 11/25

--

- Final project presentations: 12/2 9:30-10:45am (Bren Hall 1414); 12/7 8-10:30am (Bren Hall 14**2**4)
  + You will _randomly_ be assigned a slot (slots announced 11/24)

---
name: Overview

# Today

#### Refresher: types of spatial data
Points, vector, raster/field, dynamic raster/field

--

#### A common challenge: spatial interpolation
Points to fields, interpolation

--

#### Kriging: a powerful form of interpolation
Variogram, kriging

---
layout: false
class: clear, middle, inverse
# Types of spatial data
---
# Spatial data

## Spatial Data can generally split into:

- .hi[Vector] Data
--
: points, lines, and polygons.

--

- .hi[Raster] Data
--
: a grid of equally sized rectangles.
--


An **alternative framing**: <i>object view</i> versus <i>field view</i> 
--

- .pink[**Object View**]: The study region (and world) is a series of entities located in space.

--

Examples
--

: Points representing cities. Non-continuous polygons representing cities.
--

- .pink[**Field View**]: Every location within the study region (and world) has a measurable value.

--

Examples
--

: Elevation. Temperature. Wind direction.

---
# Spatial data

.hi[Q]: Is there a <i>best</i> data type to represent objects or fields?

--

.hi[A]: Usually, but it depends. 


```{R, v_vs_r, out.width = "30%", echo = F}
include_graphics("Vector_vs_raster.jpg")
```

--

- Usually it will be easier to represent .pink[**objects**] with .hi[vector data] and .pink[**fields**] with .hi[raster] data, but ultimately this depends on what analysis you want to run

--

- Luckily, `R` makes it easy to switch back and forth (but we need to be careful and intentional when transforming!)

---
layout: false
class: clear, middle, inverse
# Spatial interpolation

---
# Spatial interpolation

### In environmental data science, we are **often interested in modeling fields**


```{R, wildfire, out.width = "40%", echo = F}
include_graphics("wildfirerisk.png")
```

---
# Spatial interpolation

### But we are doing **statistics!**

--

That means we only have data from a _sample_, not a census of the _population_

```{R, sample, out.width = "85%", echo = F}
include_graphics("raster_vs_sample.png")
```

---
# Spatial interpolation

- Samples taken from a continuous spatial field often raise the need for **spatial interpolation**

--

#### Definition:
#### Spatial interpolation is the process of using a **sample** of observed points to estimate values for **all locations** in a study region

--

For example:
  + Predicting "gold grades" across South Africa using a few borehole samples (the problem of Daniel _Krige_!)
  + Predicting depth to groundwater across California using monitoring wells
  + Predicting air pollution across China using monitoring stations

---
# Spatial interpolation in math

- Let $Z(x_0)$ indicate the value (e.g., elevation) at a location $x_0$ that was _not_ sampled

--

- Let $Z(x_i)$ for $i=1,...m$ indicate the values for locations $i=1,...,m$ that _were_ sampled

--

**Spatial interpolation** aims to predict $Z(x_0)$ using a linear combination of the values in the sampled locations:

$$\hat Z(x_0) = \sum_{i=1}^m \lambda_i Z(x_i)$$
where $\lambda_i$ are weights applied to each sampled location.

--

- All spatial interpolation methods assume or derive a set of $\lambda$'s to compute $\hat Z$'s

---
# Interpolation in pictures

```{R, interpvisual, out.width = "80%", echo = F}
include_graphics("spatialinterp_picture.png")
```


---
# Interpolation in one dimension

Consider one-dimensional space where values $y$ depend on location $x$ 

```{r, fig.height=2, echo=FALSE}
set.seed(1234)
x = runif(100, min = 0, max = 100)
z = 10 + sin(.1*x) + .5*rnorm(100)
data = data.frame(x,z)
ggplot(data = data, aes(x,z)) + geom_point(color="seagreen", size=2.5) + 
  theme_bw() + theme(
  line = element_blank(),
  panel.grid = element_blank(),
  rect = element_blank(),
  strip.text = element_blank(),
  axis.text.x = element_text(size = 14),
  axis.text.y = element_text(size = 14),
  legend.position = "none")
```

---
# Interpolation in one dimension

Consider one-dimensional space where values $z$ depend on location $x$ 

```{r,  fig.height=2,  echo=FALSE}
ggplot(data = data, aes(x,z)) + geom_point(color="seagreen", size=2.5) + 
  geom_smooth(method = lm, formula = y ~ poly(x,8), se = FALSE, color = "lightcoral", size=2) + 
  theme_bw() + theme(
  line = element_blank(),
  panel.grid = element_blank(),
  rect = element_blank(),
  strip.text = element_blank(),
  axis.text.x = element_text(size = 14),
  axis.text.y = element_text(size = 14),
  legend.position = "none")
```
---
# Interpolation in two dimensions

Often we have data for an outcome $z$ observed in 2-D space: $z(x, y)$

[Draw it!]

--

```{r}
include_graphics("raster_vs_sample.png")
```

---
# Interpolation methods

## Polynomial regression

.pull-left[
```{r,  fig.height=1,  echo=FALSE}
ggplot(data = data, aes(x,z)) + geom_point(color="seagreen", size=2.5) + 
  geom_smooth(method = lm, formula = y ~ poly(x,8), se = FALSE, color = "lightcoral", size=2) + 
  theme_bw() + theme(
  line = element_blank(),
  panel.grid = element_blank(),
  rect = element_blank(),
  strip.text = element_blank(),
  axis.text.x = element_text(size = 14),
  axis.text.y = element_text(size = 14),
  legend.position = "none")
```
]

.pull-right[
- In one-dimensional space:

$$ \hat Z(x_0) = \hat\beta_0 + \hat\beta_1x_0 + \hat\beta_2x_0^2 + ... + \hat\beta^px_0^p $$
- In two-dimensional space with $(x_{0},y_0)$ the unknown value: 

$$ \hat Z(x_0,y_0) = \hat\beta_0 + \hat\beta_1x_0 + \hat\beta_2y_0 + \hat\beta_3x_0y_0 + \hat\beta_4x_0^2 + ... $$
]

--

- **Pros:** Easy, analytical expression, continuous & differentiable surface
- **Cons:** Errors can be large, _inexact_

--

**Exact:** Predicts a value identical to the measured value.

--

**Inexact:** Does _not_ predict a value identical to the measured value.

---
# Polynomial regression interpolation 

This is just **multiple linear regression** using spatial information as the independent variable

```{r, echo =T, results='hide'}
mod = lm(z~poly(x,8))
predictions = augment(mod)$.fitted
```
```{r, echo=F, fig.height=1}
ggplot(augment(mod)) + geom_line(aes(x=x, y=.fitted), color = "lightcoral", size=2) + 
  theme_bw() + theme(
  line = element_blank(),
  panel.grid = element_blank(),
  rect = element_blank(),
  strip.text = element_blank(),
  axis.text.x = element_text(size = 14),
  axis.text.y = element_text(size = 14),
  legend.position = "none")
```

---
# Interpolation methods

## Nearest Neighbors (NN) 

--

- Simple: Assign value of nearest observation in space

--

```{R, nn, out.width = "85%", echo = F}
include_graphics("theissen.png")
```

--

- Creates what are called "Theissen Polygons", which allocate space to the nearest sampled point

---
# Nearest Neighbor interpolation

.hi[Q:] What would the weight vector $\lambda$ look like for NN interpolation?

--

.hi[Q:] What type of function does NN interpolation produce for 1-D space? [draw it!]

--

- **Pros:** Easy, intuitive, field may actually be discontinuous, exact
- **Cons:** Discontinuous, error-prone if field is smooth

--

#### Implementation in `R`

- Easy with the `voronoi()` function from the `dismo` package:

```{r,echo=TRUE,eval=FALSE}
library(dismo)
v <- voronoi(dta)
plot(v)
```

--

- Helpful tutorial [here](https://rspatial.org/raster/analysis/4-interpolation.html)

---
# Interpolation methods 

## Inverse distance weighting

Basic idea: weights are a decreasing function of distance from $x_0$ to $x_i$ 

$$\hat Z(x_0) = \sum_{i=1}^m \frac{Z(x_i)Dist(x_i,x_0)^{-p}}{\sum_{i=1}^m Dist(x_i,x_0)^{-p}}$$

Equivalently:

$$\lambda_i^{IDW} = \frac{1/Dist(x_i,x_0)^p}{\sum_{i=1}^m 1/Dist(x_i,x_0)^p}$$ 

where $p$ is the "power parameter" determining how fast the weight declines as the distance between the points grows larger  

---
# Interpolation methods 

## Inverse distance weighting

- **Pros:** Smooth, exact
- **Cons:** Difficult/computationally intensive (you need to compute distances for _all_ pairs of points in the region!), all sampled observations influence $\hat Z(x_0)$, have to choose $p$ somehow

--

#### Implementation in `R` 

```{r, echo=T, eval=F}
library(phylin)
idw(values, coords, grid, method = "Shepard", p = 2, R = 2, N = 15,
    distFUN = geo.dist, ...)
```

- Note the `method` argument: "Shepard" follows the math on the previous slide
- Note the `p` argument: Need to specify power parameter

---
# Interpolation methods

## There are many more! 

- Piecewise linear interpolation / Delany triangulation
- Local polynomial regression
- Radial basis function (RBF)
- Kriging (of many forms)
- Many new machine-learning based methods
- Learn more in [Li and Heap (2014)](https://doi.org/10.1016/j.envsoft.2013.12.008)

<!-- ---
- Polynomial 
- Nearest neighbor / Theissen polygons
- Inverse distance weighting
- Piecewise linear / Delany triangulation
- KRIGING
-->

---
# Enter: Kriging

### Kriging is the most widely used form of spatial interpolation in spatial statistics.

--

### Why? 
- It is _flexible_ (i.e., less researcher decisions, more data-driven)
- Under certain assumptions it is the "best linear unbiased estimate" (sound like OLS yet??)
- You can recover an estimate _and_ a standard error (i.e., it is _stochastic_)

--

We will study **kriging** and its implementation in `R` in the next lecture and lab

---

class: center, middle


Slides created via the R package [**xaringan**](https://github.com/yihui/xaringan).

---
exclude: true

```{css, echo = FALSE}
@media print {
  .has-continuation {
    display: block;
  }
}
```

```{R, printpdfs, echo = F, eval = F}
pagedown::chrome_print(
  input = "08-kriging.html",
  output = "08-kriging.pdf",
  timeout = 60
)
```
